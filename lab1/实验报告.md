# lab1

# 网络架构

我使用的网络是一个多层感知机MLP，有两个线性层，两个`RELU`激活函数和一个`Sigmoid`层，具体参数和代码如下

```jsx
class MLP(nn.Module):
    def __init__(self):
        super(MLP, self).__init__()
        self.fc1 = nn.Linear(2, 64)
        self.relu1 = nn.ReLU()
        self.fc2 = nn.Linear(64, 32)
        self.relu2 = nn.ReLU()
        self.fc3 = nn.Linear(32, 4)
        self.sigmoid = nn.Sigmoid()

    def forward(self, x):
        out = self.fc1(x)
        out = self.relu1(out)
        out = self.fc2(out)
        out = self.relu2(out)
        out = self.fc3(out)
        out = self.sigmoid(out)
        return out
```

结构图如下

![Untitled](lab1%20d46623e010d9430288962902c7df6f1f/Untitled.png)

损失函数采用交叉熵损失函数，优化器采用`SGD` ，其中学习率为0.01，`momentum`为0.9

```jsx
# 定义损失函数和优化器
criterion = nn.CrossEntropyLoss()
optimizer = torch.optim.SGD(model.parameters(),momentum=0.9, lr=0.001)
```

# 数据集

调用`from torch.utils.data import TensorDataset, DataLoader` 将CSV文件中的参数制作为数据集，使用`one_hot`独热编码将不同的种类分开。然后调用`from sklearn.model_selection import train_test_split` 进行数据集分割。对应代码和注释如下

```jsx
# 加载数据集
data = pd.read_csv('dataset.csv')

# 随机排序数据集
data = shuffle(data)

# 划分特征和标签
X = data[['data1', 'data2']].values
y = data['label'].values
y = y-1

#数据集分割
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1)
X_train = torch.tensor(X_train,dtype=torch.float32)
X_test = torch.tensor(X_test,dtype=torch.float32)
y_train = torch.tensor(y_train,dtype=torch.long)
y_test = torch.tensor(y_test,dtype=torch.long)

y_train = F.one_hot(y_train)
y_test = F.one_hot(y_test)
_, y_test_labels = torch.max(y_test, 1)

# 创建TensorDataset和DataLoader用于批量训练
train_dataset = TensorDataset(X_train, y_train)
train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)
test_dataset = TensorDataset(X_test, y_test)
test_loader = DataLoader(test_dataset, batch_size=32, shuffle=True)
```

# 训练

采用标准的模型训练方式，`Epoch`设置为150.

```python
num_epochs = 150
for epoch in range(num_epochs):
    for inputs, targets in train_loader:
        # Forward pass
        outputs = model(inputs)
        loss = criterion(outputs, targets.float())
        
        # Backward pass and optimization
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
```

# 实验结果

实验环境为MacOS Apple Silicon M1 Pro，Python版本3.9，Pytorch版本2.0.0(MacOS版)

模型在120轮左右收敛，损失在0.83左右波动，测试集上的准确率为0.92，具体的训练Loss太长，在notebook中有完整呈现。

![Untitled](lab1%20d46623e010d9430288962902c7df6f1f/Untitled%201.png)